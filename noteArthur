Documentation:
L'essentiel de Kubernetes en 7mn:
https://www.youtube.com/watch?v=NChhdOZV4sY

Installation:
Mettre "export MINIKUBE_HOME=~/goinfre/" dans ./zshrc pour preserver la memoire de la session 
https://kubernetes.io/docs/setup/learning-environment/minikube/

Deploying WordPress and MySQL with Persistent Volumes:
https://kubernetes.io/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/

Fichier de configuation du serveur sshd_config:
http://www.octetmalin.net/linux/tutoriels/ssh-fichier-etc-sshd_config-configuration-machine-serveur.php
A guide to SSH Port:
https://www.booleanworld.com/guide-ssh-port-forwarding-tunnelling/

Persistent Volume: 
https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/

Dashboard:
https://kubernetes.io/fr/docs/tasks/access-application-cluster/web-ui-dashboard/

Ingress Controller:
https://kubernetes.io/fr/docs/concepts/services-networking/ingress/

Grafana:
https://octoperf.com/blog/2019/09/19/kraken-kubernetes-influxdb-grafana-telegraf/

SSL:
https://www.nginx.com/blog/secure-distribution-ssl-private-keys-nginx/

Cheat Sheet:

The minikube start command can be used to start your cluster. This command creates and configures a Virtual Machine that runs a single-node Kubernetes cluster. This command also configures your kubectl installation to communicate with this cluster.
minikube start --vm-driver=virtualbox --extra-config=apiserver.service-node-port-range=1-10000

Bug:
run "kubectl describe pvc"      to confirm if this is the bug

Deployment:
Let’s create a Kubernetes Deployment using an existing image named echoserver, which is a simple HTTP server and expose it on port 8080 using --port.
kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.10
kubectl apply -k .


To access the hello-minikube Deployment, expose it as a Service:
kubectl expose deployment hello-minikube --type=NodePort --port=8080
The option --type=NodePort specifies the type of the Service.

The hello-minikube Pod is now launched but you have to wait until the Pod is up before accessing it via the exposed Service.
Check if the Pod is up and running: kubectl get pod

Get the URL of the exposed Service to view the Service details:
minikube service hello-minikube --url

Delete the hello-minikube Service:
kubectl delete services hello-minikube

Delete the hello-minikube Deployment:
kubectl delete deployment hello-minikube
kubectl delete -k ./

Stop the local Minikube cluster:
minikube stop

Delete the local Minikube cluster:
minikube delete

To access the Kubernetes Dashboard, run this command in a shell after starting Minikube to get the address:
minikube dashboard


To determine the NodePort for your service, you can use a kubectl command like this:
kubectl get service $SERVICE --output='jsonpath="{.spec.ports[0].nodePort}"'


The Minikube VM boots into a tmpfs, so most directories will not be persisted across reboots (minikube stop). However, Minikube is configured to persist files stored under the following host directories:
/data
/var/lib/minikube
/var/lib/docker

Deployments
A Deployment provides declarative updates for Pods and ReplicaSets.

You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.
https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#use-case


Ingress Controller:
https://kubernetes.github.io/ingress-nginx/deploy/

Pod Templates
Pod templates are pod specifications which are included in other objects, such as Replication Controllers, Jobs, and DaemonSets. Controllers use Pod Templates to make actual pods. The sample below is a simple manifest for a Pod which contains a container that prints a message.

apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', 'echo Hello Kubernetes! && sleep 3600']

Example Pod with emptyDir / Volume:

apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume
    emptyDir: {}

The following is an example of PersistentVolume spec using a local volume and nodeAffinity:

apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv
spec:
  capacity:
    storage: 100Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage
  local:
    path: /mnt/disks/ssd1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - example-node




Defining a Service
A Service in Kubernetes is a REST object, similar to a Pod. Like all of the REST objects, you can POST a Service definition to the API server to create a new instance.

For example, suppose you have a set of Pods that each listen on TCP port 9376 and carry a label app=MyApp:

apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
This specification creates a new Service object named “my-service”, which targets TCP port 9376 on any Pod with the app=MyApp label.


Using subPath / Volume data storage
Sometimes, it is useful to share one volume for multiple uses in a single Pod. The volumeMounts.subPath property can be used to specify a sub-path inside the referenced volume instead of its root.

Here is an example of a Pod with a LAMP stack (Linux Apache Mysql PHP) using a single, shared volume. The HTML contents are mapped to its html folder, and the databases will be stored in its mysql folder:

apiVersion: v1
kind: Pod
metadata:
  name: my-lamp-site
spec:
    containers:
    - name: mysql
      image: mysql
      env:
      - name: MYSQL_ROOT_PASSWORD
        value: "rootpasswd"
      volumeMounts:
      - mountPath: /var/lib/mysql
        name: site-data
        subPath: mysql
    - name: php
      image: php:7.0-apache
      volumeMounts:
      - mountPath: /var/www/html
        name: site-data
        subPath: html
    volumes:
    - name: site-data
      persistentVolumeClaim:
        claimName: my-lamp-site-data

Creating a Deployment
The following is an example of a Deployment. It creates a ReplicaSet to bring up three nginx Pods:

controllers/nginx-deployment.yaml Copy controllers/nginx-deployment.yaml to clipboard

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
https://kubernetes.io/docs/concepts/workloads/controllers/deployment/

